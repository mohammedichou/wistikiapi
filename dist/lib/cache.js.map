{"version":3,"sources":["lib/cache.js"],"names":["bluebird","promisifyAll","redis","RedisClient","prototype","Multi","debug","require","client","createClient","host","process","env","CACHE_HOST","config","port","retry_strategy","options","error","code","redisLogger","Error","total_retry_time","times_connected","Math","max","attempt","on","err","KEY_MAPPING","POSITION_WISTIKI","POSITION_DEVICE","Cache","_client","key","multi","exists","hgetall","execAsync","then","result","exist","position","_","isObject","JSON","parse","coordinates","date","Date","utc","toISOString","accuracy","parseInt","id","resolve","catch","reject","localisation","stringifiedLocalisation","cloneDeep","isString","_getLastPosition","last_position","isBefore","hmset","serial_number","uid","serialNumber","_setLastPosition","keysAsync","keys","length","del","join","email","each","get","results","getAsync","models","setAsync"],"mappings":"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","file":"cache.js","sourcesContent":["import redis from 'redis';\nimport moment from 'moment';\nimport _ from 'lodash';\nimport bluebird from 'bluebird';\nimport { redisLogger } from './logger';\nimport config from '../config';\n\nbluebird.promisifyAll(redis.RedisClient.prototype);\nbluebird.promisifyAll(redis.Multi.prototype);\n\nconst debug = require('debug')('darwin:cache');\n\nconst client = redis.createClient({\n  host: process.env.CACHE_HOST ? process.env.CACHE_HOST : config.redis.host,\n  port: config.redis.port,\n  retry_strategy(options) {\n    if (options.error.code === 'ECONNREFUSED') {\n      // End reconnecting on a specific error and flush all commands with a individual error\n      redisLogger.error('redis error', options.error);\n      return new Error('The server refused the connection');\n    }\n    if (options.total_retry_time > 1000 * 60 * 60) {\n      // End reconnecting after a specific timeout and flush all commands with a individual error\n      redisLogger.error('redis error', { error: 'Retry time exhausted' });\n      return new Error('Retry time exhausted');\n    }\n    if (options.times_connected > 10) {\n      redisLogger.error('redis error', { error: 'End reconnecting with built in error' });\n      // End reconnecting with built in error\n      return null;\n    }\n    // reconnect after\n    return Math.max(options.attempt * 100, 3000);\n  },\n});\n\nclient.on('ready', () => {\n  debug('redis client ready');\n  redisLogger.debug('redis ready');\n});\n\n// look for connection errors and log\nclient.on('error', (err) => {\n  debug('redis client error', err);\n  redisLogger.error('redis error', err);\n});\nconst KEY_MAPPING = {\n  POSITION_WISTIKI: 'p:w:',\n  POSITION_DEVICE: 'p:d:',\n};\n\nclass Cache {\n  constructor() {\n    this._client = client;\n  }\n\n  get client() {\n    return this._client;\n  }\n\n  /**\n   * Retrieves last position object\n   * @param {string} key hash key where position object is stored\n   * @return {Promise.<Array>} index 0 contains boolean indication\n   * if hash key has been found or not and index 1\n   * contains position object\n   *\n   * @private\n   */\n  _getLastPosition(key) {\n    debug(`_getLastPosition ${key}`);\n    return this.client.multi()\n      .exists(key)\n      .hgetall(key)\n      .execAsync()\n      .then((result) => {\n        const exist = !!result[0];\n        const position = result[1];\n        debug('_getLastPosition got position from cache of type: %s,', typeof position, position);\n        if (position && position.position && !_.isObject(position.position)) {\n          debug('_getLastPosition got position.position of type: %s from cache:', typeof position.position, position.position);\n          position.position = JSON.parse(position.position);\n          debug('_getLastPosition got position.position.coordinates of type: %s from cache:', typeof position.position.coordinates, position.position.coordinates);\n          if (!_.isObject(position.position.coordinates)) {\n            position.position.coordinates = JSON.parse(position.position.coordinates);\n          }\n          position.date = moment(new Date(position.date)).utc().toISOString();\n          position.accuracy = parseInt(position.accuracy);\n          position.id = parseInt(position.id);\n        }\n        debug('_getLastPosition found: ', [exist, position]);\n        return Promise.resolve([exist, position]);\n      })\n      .catch((err) => {\n        debug(`_getLastPosition ${key} error`, err);\n        return Promise.reject(err);\n      });\n  }\n\n  /**\n   * Store localisation object in cache. Before inserting new position, it checks if\n   * there is another position stored\n   * within the same key. It does not exist it insert the new object. if it exists,\n   * it checks positon date before going\n   * further. In case new position date is before last saved position, promise will be rejected\n   *\n   * @param {string} key hash key\n   * @param {object} localisation object representing position Model\n   * @return {Promise.<object>} inserted localisation object\n   *\n   * @private\n   */\n  _setLastPosition(key, localisation) {\n    debug('_setLastPosition: key: %s, localisation:', key, localisation);\n    const stringifiedLocalisation = _.cloneDeep(localisation);\n    if (!_.isString(stringifiedLocalisation.position)) {\n      stringifiedLocalisation.position.coordinates = JSON.stringify(localisation.position.coordinates);\n      stringifiedLocalisation.position = JSON.stringify(localisation.position);\n    }\n\n    stringifiedLocalisation.accuracy = parseInt(stringifiedLocalisation.accuracy);\n\n    return this._getLastPosition(key)\n      .then((result) => {\n        debug('_setLastPosition found record: ', result);\n\n        const exist = result[0];\n        const last_position = result[1];\n\n        if (!exist || last_position.date && moment(new Date(last_position.date)).isBefore(new Date(localisation.date))) {\n          debug('will set into cache: ', stringifiedLocalisation);\n          return this.client.multi().hmset(key, stringifiedLocalisation)\n            .execAsync()\n            .then((result) => {\n              if (result == 'OK') {\n                debug('_setLastPosition position set will return ', localisation);\n                return Promise.resolve(localisation);\n              }\n              debug('_setLastPosition redis returned: ', result);\n              return Promise.reject(new Error(result));\n            });\n        }\n        debug(`Position not set. Previous position exists? ${exist}, last_position date: ${last_position.date}, new position date: ${localisation.date}`);\n        // return Promise.reject(new Error(`Previous position exists? ${exist}, last_position date: ${last_position.date}, new position date: ${localisation.date}`));\n        return Promise.resolve(last_position);\n      })\n      .catch((err) => {\n        debug('setLastWistikiPosition error', err);\n        return Promise.resolve(err);\n      });\n  }\n\n\n  /**\n   * Returns last Wistiki position record in cache.\n   *\n   * @param {string|number} serial_number\n   * @return {Promise.<object>} containing last position object or null if it does not exist\n   */\n  getLastWistikiPosition(serial_number) {\n    const key = `${KEY_MAPPING.POSITION_WISTIKI}${serial_number}`;\n    return this._getLastPosition(key).then(result => result[1]);\n  }\n\n  /**\n   * Returns last Device position record in cache.\n   *\n   * @param {string|number} uid\n   * @return {Promise.<object>} localisation position object if it exists or null if not found\n   */\n  getLastDevicePosition(uid) {\n    const key = `${KEY_MAPPING.POSITION_DEVICE}${uid}`;\n    return this._getLastPosition(key).then(result => result[1]);\n  }\n\n  /**\n   * Retrieve last wistiki position. If it does not exist it will insert position otherwise it will check last\n   * position date before setting new position.\n   *\n   * @param {string|number} serial_number Wistiki serial number\n   * @param {object} localisation json object representing Position Model\n   * @return {Promise.<Object>} with inserted localisation object\n   */\n  setLastWistikiPosition(serialNumber, position) {\n    debug('setLastWistikiPosition %s', serialNumber, position);\n    const key = `${KEY_MAPPING.POSITION_WISTIKI}${serialNumber}`;\n    return this._setLastPosition(key, position);\n  }\n\n  setLastDevicePosition(uid, position) {\n    const key = `${KEY_MAPPING.POSITION_DEVICE}${uid}`;\n    return this._setLastPosition(key, position);\n  }\n\n  async deleteDeviceHasUser(uid) {\n    const keys = await this.client.keysAsync(`model:device_has_user:${uid}:*`);\n    if (keys.length) {\n      return this.client.multi().del(keys.join(' ')).execAsync();\n    }\n    return Promise.resolve();\n  }\n\n  async getUserDevices(email) {\n    const keys = await this.client.keysAsync(`model:device_has_user:*:${email}`);\n    if (keys.length) {\n      const multi = this.client.multi();\n      _.each(keys, (key) => {\n        multi.get(key);\n      });\n      const results = await multi.execAsync();\n      return JSON.parse(results);\n    }\n    return Promise.resolve();\n  }\n\n  async getWistikiHasOwner(email, serialNumber) {\n    const keys = await this.client.keysAsync(`model:wistiki_has_owner:${serialNumber}:${email}:*`);\n    if (keys.length) {\n      const results = await this.client.getAsync(keys[0]);\n      return JSON.parse(results);\n    }\n    return Promise.resolve();\n  }\n\n  async deleteWistikiHasOwner(email, serialNumber) {\n    const keys = await this.client.keysAsync(`model:wistiki_has_owner:${serialNumber}:${email}`);\n    if (keys.length) {\n      return this.client.multi().del(keys.join(' ')).execAsync();\n    }\n    return Promise.resolve();\n  }\n\n  async getWistikiHasFriend(email, serialNumber) {\n    const keys = await this.client.keysAsync(`model:wistiki_has_friend:${serialNumber}:${email}:*`);\n    if (keys.length) {\n      const results = await this.client.getAsync(keys[0]);\n      return JSON.parse(results);\n    }\n    return Promise.resolve();\n  }\n\n  async deleteWistikiHasFriend(email, serialNumber) {\n    const keys = await this.client.keysAsync(`model:wistiki_has_friend:${serialNumber}:${email}:*`);\n    if (keys.length) {\n      return this.client.multi().del(keys.join(' ')).execAsync();\n    }\n    return Promise.resolve();\n  }\n\n  async getModels() {\n    debug('getModels');\n    const result = await this.client.getAsync('models');\n    return JSON.parse(result);\n  }\n\n  async setModels(models) {\n    debug('setModels');\n    this.client.setAsync('models', JSON.stringify(models), 'EX', 60 * 60 * 24);\n  }\n}\n\nexport default new Cache();\n\n"],"sourceRoot":"/opt/atlassian/pipelines/agent/build/src"}